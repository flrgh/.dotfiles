#!/usr/bin/env bash

set -euo pipefail

readonly MAN=$HOME/.local/share/man
readonly MAN1="$MAN"/man1

log() {
    echo "$@"
}

setup() {
    mkdir -p "$MAN" "$MAN1"

    # cleanup cat directories
    shopt -s nullglob
    rm -rf "$MAN"/cat[1-9]
}

exists() {
    command -v "$@" &>/dev/null
}

check-exists() {
    local -r cmd=${1:?}
    if ! exists "$cmd"; then
        log "$cmd not found"
        return 1
    fi
}

mtime() {
    local ref=${1:?}
    local -r target=${2:?}

    if [[ $ref != */* ]]; then
        # $ref is the name of a command
        if exists "$ref"; then
            ref=$(./scripts/bin-path "$ref")
        else
            ref=$(realpath "$ref")
        fi
    fi

    touch --no-create \
        --reference "$ref" \
        "$target"
}

add-man-path() {
    local -r mp=${1:?}

    if [[ ! -d $mp ]]; then
        log "error: $mp not found or not a directory"
        return 1
    fi

    local rel subdir

    shopt -s failglob

    for subdir in "$mp"/man[0-9]; do
        rel=${MAN}${subdir#"$mp"}
        ./scripts/symlink-tree "$subdir" "$rel"
    done
}

add-man-1() {
    if (( $# == 0 )); then
        log "error: no paths provided"
        return 1
    fi

    local p
    for p in "$@"; do
        if [[ ! -e $p ]]; then
            log "error: path $p does not exist"
            return 1
        fi
    done

    install \
        --mode 0664 \
        --preserve-timestamps \
        --target-directory "$MAN1" \
        "$@"
}

man-1-from-cmd-named() {
    local -r name=${1:?}
    shift

    local -r bin=${1:-}

    if ! exists "$bin"; then
        log "$name / $bin not found"
        return 1
    fi

    local -r dest="${MAN1}/${name}.1"
    "$@" > "$dest"
    mtime "$bin" "$dest"
}


man-1-from-cmd() {
    local -r bin=${1:?}
    man-1-from-cmd-named "${bin##*/}" "$@"
}

# chmod 0664 all regular files (not symlinks) in the man page dirs
fix-perms() {
    shopt -s failglob
    local f
    for f in "${MAN}"/man[1-9]/*; do
        if [[ -f $f && ! -L $f ]]; then
            chmod 0664 "$f"
        fi
    done
}

_git_cliff() {
    check-exists git-cliff || return

    local where; where=$(mise where git-cliff)
    shopt -s failglob

    local man=("${where}"/*/man/git-cliff.1)
    add-man-1 "${man[0]}"
}

_fzf() {
    check-exists fzf || return

    local bin; bin=$(mise which fzf)

    # -R tells `man` to re-encode the input rather than formatting it for display
    MANOPT='-R' "$bin" --man > "$MAN1/fzf.1"
    mtime "$bin" "$MAN1/fzf.1"
}

_gh() {
    check-exists gh || return

    local where; where=$(mise where gh)
    shopt -s failglob
    local man=("${where}"/*/share/man)

    add-man-path "${man[0]}"
}

_ripgrep() {
    check-exists rg || return

    local rg; rg=$(mise which rg)
    man-1-from-cmd "$rg" --generate man
}

_rustup() {
    check-exists rustup || return

    local active
    active=$(rustup show active-toolchain | awk '{print $1}')

    add-man-path "${RUSTUP_HOME:?}/toolchains/${active:?}/share/man"
}

_node() {
    local node; node=$(mise where node)
    add-man-path "${node}/share/man"
}

_npm() {
    check-exists npm || return
    add-man-path "$HOME/.local/lib/node_modules/npm/man"
}

_fd() {
    check-exists fd || return

    local bin; bin=$(mise which fd)
    add-man-1 "${bin}.1"
}

_nfpm() {
    check-exists nfpm || return

    local where; where=$(mise where nfpm)

    shopt -s failglob
    add-man-1 "${where}"/manpages/*
}

_python() {
    local where; where=$(mise where python)
    add-man-path "$where"/share/man
}

_http() {
    if exists http; then
        man-1-from-cmd http --generate man
        return
    fi

    if exists xh; then
        log "generating http man page with xh"
        man-1-from-cmd-named http xh --generate man
    fi
}

_xh() {
    check-exists xh || return
    man-1-from-cmd xh --generate man
}


main() {
    setup

    _fd
    _fzf
    _gh
    _git_cliff
    _http
    _nfpm
    _node
    _npm
    _python
    _ripgrep
    _rustup
    _xh

    fix-perms
}

main "$@"
